<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Drawing the Aperiodic Hat tiling with python and z3</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <!-- <li><a href="/FeatureMapICON/">Feature Map Inverse Consistency</a> --> <li><a href="/ICON/">Inverse Consistent Regstration</a> <li><a href="/Mandelbrot/">Mandelbrot Set Adventures</a> <li><a href="/BadMatrixMultiply/">Bad Matrix Multiplication</a> <li><a href="/GameJam/">Game Jam Games</a> <li><a href="/menu3/">Tags</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=drawing_the_aperiodic_hat_tiling_with_python_and_z3 ><a href="#drawing_the_aperiodic_hat_tiling_with_python_and_z3" class=header-anchor >Drawing the Aperiodic Hat tiling with python and z3</a></h1> <p><a href="https://colab.research.google.com/drive/1ohrJjN5pkFzgXRec1RPSDrL-6yhJ11Nv?usp&#61;sharing">colab notebook</a></p> <p><a href="https://www.youtube.com/watch?v&#61;_ZS3Oqg1AX0">Numbephile</a> recently put out a video on the discovery of the Hat Tile, which linked to an excellent <a href="https://hedraweb.wordpress.com/2023/03/23/its-a-shape-jim-but-not-as-we-know-it/">blog post</a> by David Smith about the discovery process. </p> <p>In David&#39;s post, he talks about a mysterious entity &quot;Craig’s Sat Solver&quot; that works on assembling tilings. In this post, This piqued my curiousit: I was familiar with using an SAT solver for sudoku solutions or finding weird matricies. Could I use it to draw the hat tiling? I&#39;m going to take a shot at showing how to tile &#40;or fail to tile&#41; arbitrary shapes using a SAT solver &#40;in this case, z3&#41;</p> <p>The hat tile has an unusual property for an aperiodic tiling: it lives on a regular grid. <p><span style="color:red;">// Image matching '/assets/HatTile/code/Unknown-7.png' not found. //</span></p></p> <p>As a result, we can enumerate all the places it is possible to put a hat or one of its component kites&#33; This would not be so easy for, e.g., the kite and dart tiling.</p> <p>First we set up arrays that we can use to make translated or rotated copies of an object</p> <pre><code class="python hljs"><span class=hljs-keyword >import</span> matplotlib.pyplot <span class=hljs-keyword >as</span> plt
<span class=hljs-keyword >import</span> numpy <span class=hljs-keyword >as</span> np

grid_size = <span class=hljs-number >6</span>
x, y = np.mgrid[-<span class=hljs-number >2</span>:grid_size - <span class=hljs-number >2</span>, -<span class=hljs-number >2</span>:grid_size - <span class=hljs-number >2</span>]
hexagon_centers = x + <span class=hljs-number >.5</span> * y + <span class=hljs-number >1j</span> * np.sqrt(<span class=hljs-number >3</span>) / <span class=hljs-number >2</span> * y
six_rotations = np.exp(<span class=hljs-number >1j</span> * (np.pi /<span class=hljs-number >3</span> * np.arange(<span class=hljs-number >6</span>)))</code></pre> <p>Then, we define the &#39;kite&#39; object that we will assemble into a hat</p> <pre><code class="python hljs">kite = np.array([<span class=hljs-number >0</span>, <span class=hljs-number >.5</span>, <span class=hljs-number >1</span> / np.sqrt(<span class=hljs-number >3</span>) * np.exp(<span class=hljs-number >1j</span> * np.pi / <span class=hljs-number >6</span>), <span class=hljs-number >.5</span> * np.exp(<span class=hljs-number >1j</span> * np.pi / <span class=hljs-number >3</span>), <span class=hljs-number >0</span>])
kites = kite[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :] * six_rotations[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, <span class=hljs-literal >None</span>]
kites = kites + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]</code></pre> <p>The hat is composed of 8 kites from the grid</p> <pre><code class="python hljs">indices = [
    [<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>], <span class=hljs-comment >#row</span>
    [<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>], <span class=hljs-comment >#col</span>
    [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >5</span>, <span class=hljs-number >4</span>]  <span class=hljs-comment >#rotation</span>
    ]
hat = kites[indices[<span class=hljs-number >0</span>], indices[<span class=hljs-number >1</span>], indices[<span class=hljs-number >2</span>], :]</code></pre> <p>Next, we make a big i x j x θ x kite-in-hat x vertex-in-kite array of all possible hats.</p> <pre><code class="python hljs">hats = hat[<span class=hljs-literal >None</span>, :, :] * six_rotations[:, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
hats = np.concatenate([hats, np.real(hats) - <span class=hljs-number >1j</span> * np.imag(hats)])
hats = hats[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, :, :] + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
hats = np.reshape(hats, (-<span class=hljs-number >1</span>, <span class=hljs-built_in >len</span>(hat), <span class=hljs-number >5</span>))</code></pre> <p>Now it&#39;s time to set up our z3 solver. We want to pick a subset of all possible hats such that every kite is in exactly one hat. To do this, we compute every kite center, and create a map from kite centers to lists of hats that cover them</p> <pre><code class="python hljs">hat_centers = np.mean(hats, axis=-<span class=hljs-number >1</span>)
hat_centers = np.<span class=hljs-built_in >round</span>(hat_centers, <span class=hljs-number >2</span>)
hats_with_point = defaultdict(<span class=hljs-keyword >lambda</span>: [])
<span class=hljs-keyword >for</span> hat_index, centers <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(hat_centers):
  <span class=hljs-keyword >for</span> loc <span class=hljs-keyword >in</span> centers:
    hats_with_point[loc] += [hat_index]</code></pre> <pre><code class="python hljs">max_pop = <span class=hljs-built_in >max</span>(<span class=hljs-built_in >len</span>(c) <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items())
full_points = np.array([p <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items() <span class=hljs-keyword >if</span> <span class=hljs-built_in >len</span>(c) == max_pop])
all_points = np.array([p <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items()])
<span class=hljs-keyword >def</span> <span class="hljs-title function_">atleastone</span>(<span class=hljs-params >solver, bools</span>):
  solver.add(z3.Or(bools))
<span class=hljs-keyword >def</span> <span class="hljs-title function_">atmostone</span>(<span class=hljs-params >solver, bools</span>):
  <span class=hljs-comment >#solver.add(z3.PbLe([(x,1) for x in bools], 1))</span>
  <span class=hljs-keyword >for</span> i, b1 <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(bools):
    <span class=hljs-keyword >for</span> j, b2 <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(bools):
      <span class=hljs-keyword >if</span> i &gt; j:
        solver.add(z3.Not(z3.And(b1, b2)))
hat_present = [z3.Bool(<span class=hljs-string >f&quot;hat<span class=hljs-subst >{i}</span>&quot;</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(hats))]
s = z3.Solver()
<span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> all_points:
  atmostone(s, [hat_present[i] <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> hats_with_point[p]])
<span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> full_points:
  atleastone(s, [hat_present[i] <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> hats_with_point[p]])
<span class=hljs-built_in >print</span>(s.check())
m = s.model()
chosen_hats = np.array([z3.is_true(m[h]) <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> hat_present])
hat = np.<span class=hljs-built_in >round</span>(hat, <span class=hljs-number >2</span>)
segments = np.concatenate([hat[:, <span class=hljs-number >1</span>:, <span class=hljs-literal >None</span>], hat[:, :-<span class=hljs-number >1</span>, <span class=hljs-literal >None</span>]], axis=<span class=hljs-number >2</span>)
segments = segments.reshape(-<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)
reversed_segments = <span class=hljs-built_in >set</span>(((seg[<span class=hljs-number >1</span>], seg[<span class=hljs-number >0</span>]) <span class=hljs-keyword >for</span> seg <span class=hljs-keyword >in</span> segments))
outline = np.array([l <span class=hljs-keyword >for</span> l <span class=hljs-keyword >in</span> segments <span class=hljs-keyword >if</span> <span class=hljs-built_in >tuple</span>(l) <span class=hljs-keyword >not</span> <span class=hljs-keyword >in</span> reversed_segments])
outlines = outline[<span class=hljs-literal >None</span>, :] * six_rotations[:, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
outlines = np.concatenate([outlines, np.real(outlines) - <span class=hljs-number >1j</span> * np.imag(outlines)])
outlines = outlines[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, :, :] + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
outlines = np.reshape(outlines, (-<span class=hljs-number >1</span>, <span class=hljs-built_in >len</span>(outline), <span class=hljs-number >2</span>))
result = outlines[np.array(chosen_hats), :]
result = result.reshape(-<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)
plt.plot(result.imag.transpose(), result.real.transpose(), c=[<span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>])
<span class=hljs-comment >#plt.ylim(6, 17)</span>
<span class=hljs-comment >#plt.xlim(-1, 15)</span>
plt.gca().set_aspect(<span class=hljs-string >&quot;equal&quot;</span>)
plt.show()</code></pre> <div class=page-foot > <div> <a href=https://subdavis.com>subdavis.com </a> <a href=http://forrestli.con>forrestli.com</a> <div class=copyright > &copy; Hastings Greer. Last modified: July 07, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div>