<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=stylesheet  href="https://apj.hgreer.com/blog"> <link rel=icon  href="/assets/favicon.png"> <title>Drawing the Aperiodic Hat Tiling with Python and Z3</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <!-- <li><a href="/FeatureMapICON/">Feature Map Inverse Consistency</a> --> <li><a href="/HatTile/">Aperiodic Tiling with Z3</a> <!-- <li><a href="/ICON/">Inverse Consistent Regstration</a> <li><a href="/Mandelbrot/">Mandelbrot Set Adventures</a> --> <li><a href="/JavascriptMandelbrot/">Mandelbrot Set</a> <li><a href="/TrebuchetSimulator/">Trebuchet Simulator</a> <li><a href="/BadMatrixMultiply/">Bad Matrix Multiplication</a> <li><a href="/GameJam/">Game Jam Games</a> <li><a href="/menu3/">Tags</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=drawing_the_aperiodic_hat_tiling_with_python_and_z3 ><a href="#drawing_the_aperiodic_hat_tiling_with_python_and_z3" class=header-anchor >Drawing the Aperiodic Hat Tiling with Python and Z3</a></h1> <p><a href="https://colab.research.google.com/drive/1cBs3HGFQ6cz8z9o5HIr2OqhpD5A3LcqO?usp&#61;sharing">colab notebook</a></p> <p><a href="https://www.youtube.com/watch?v&#61;_ZS3Oqg1AX0">Numberphile</a> recently put out a video on the discovery of the Hat Tile, which linked to an excellent <a href="https://hedraweb.wordpress.com/2023/03/23/its-a-shape-jim-but-not-as-we-know-it/">blog post</a> by David Smith about the discovery process. </p> <p>In David&#39;s post, he talks about a mysterious entity &quot;Craig’s Sat Solver&quot; that works on assembling tilings. This piqued my curiosity: I was familiar with using an SAT solver for sudoku solutions or finding weird matricies. Could I use it to draw the hat tiling? I&#39;m going to take a shot at showing how to tile &#40;or fail to tile&#41; shapes using a SAT solver &#40;in this case, Z3&#41;</p> <p>The hat tile has an unusual property for an aperiodic tiling: it lives on a regular grid. As a result, I can enumerate all the places it is possible to put a hat or one of its component kites&#33; This would not be so easy for, e.g., the kite and dart tiling.</p> <p>First, I set up arrays that I can use to make translated or rotated copies of an object</p> <pre><code class="python hljs"><span class=hljs-keyword >import</span> matplotlib.pyplot <span class=hljs-keyword >as</span> plt
<span class=hljs-keyword >import</span> numpy <span class=hljs-keyword >as</span> np
<span class=hljs-keyword >import</span> z3
<span class=hljs-keyword >from</span> collections <span class=hljs-keyword >import</span> defaultdict

<span class=hljs-keyword >def</span> <span class="hljs-title function_">show_pts</span>(<span class=hljs-params >pts</span>):
  pts = pts.reshape(-<span class=hljs-number >1</span>, pts.shape[-<span class=hljs-number >1</span>]).transpose()
  plt.plot(pts.real, pts.imag, c=[<span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>])
  plt.gca().set_aspect(<span class=hljs-string >&quot;equal&quot;</span>)
  plt.show()

grid_size = <span class=hljs-number >21</span>
x, y = np.mgrid[-<span class=hljs-number >2</span>:grid_size - <span class=hljs-number >2</span>, -<span class=hljs-number >2</span>:grid_size - <span class=hljs-number >2</span>]
hexagon_centers = x + <span class=hljs-number >.5</span> * y + <span class=hljs-number >1j</span> * np.sqrt(<span class=hljs-number >3</span>) / <span class=hljs-number >2</span> * y
six_rotations = np.exp(<span class=hljs-number >1j</span> * (np.pi /<span class=hljs-number >3</span> * np.arange(<span class=hljs-number >6</span>)))</code></pre> <p>Then, I define a grid of &#39;kite&#39; tiles</p> <pre><code class="python hljs">kite = np.array([<span class=hljs-number >0</span>, <span class=hljs-number >.5</span>, <span class=hljs-number >1</span> / np.sqrt(<span class=hljs-number >3</span>) * np.exp(<span class=hljs-number >1j</span> * np.pi / <span class=hljs-number >6</span>), <span class=hljs-number >.5</span> * np.exp(<span class=hljs-number >1j</span> * np.pi / <span class=hljs-number >3</span>), <span class=hljs-number >0</span>])
kites = kite[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :] * six_rotations[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, <span class=hljs-literal >None</span>]
kites = kites + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
show_pts(kites[:<span class=hljs-number >5</span>, :<span class=hljs-number >5</span>])</code></pre> <img src="/assets/HatTile/code/Unknown-8.png" alt=""> <p>The hat is composed of 8 of these kites </p> <pre><code class="python hljs">indices = [
    [<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>], <span class=hljs-comment >#row</span>
    [<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>], <span class=hljs-comment >#col</span>
    [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >5</span>, <span class=hljs-number >4</span>]  <span class=hljs-comment >#rotation</span>
    ]
hat = kites[indices[<span class=hljs-number >0</span>], indices[<span class=hljs-number >1</span>], indices[<span class=hljs-number >2</span>], :]
show_pts(hat)</code></pre> <img src="/assets/HatTile/code/Unknown-9.png" alt=""> <p>Next, I collect all possible hats into an i x j x θ x kite-in-hat x vertex-in-kite array. I then flatten this array to hat-index x kite-index x vertex-in-kite since I don&#39;t need the grid structure anymore- I just want a list of hat tiles.</p> <pre><code class="python hljs">hats = hat[<span class=hljs-literal >None</span>, :, :] * six_rotations[:, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
hats = np.concatenate([hats, np.real(hats) - <span class=hljs-number >1j</span> * np.imag(hats)])
hats = hats[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, :, :] + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
hats = np.reshape(hats, (-<span class=hljs-number >1</span>, <span class=hljs-built_in >len</span>(hat), <span class=hljs-number >5</span>))</code></pre> <p>Now it&#39;s time to set up our z3 solver. I want to pick a subset of all possible hats such that every kite is in exactly one hat. To do this, I compute every kite center, and create a map from kite centers to lists of hats that cover them. &#40;Why do I identify kites by their center instead of by their edges?&#41;</p> <pre><code class="python hljs">hat_centers = np.mean(hats, axis=-<span class=hljs-number >1</span>)
hat_centers = np.<span class=hljs-built_in >round</span>(hat_centers, <span class=hljs-number >2</span>)
hats_with_point = defaultdict(<span class=hljs-keyword >lambda</span>: [])
<span class=hljs-keyword >for</span> hat_index, centers <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(hat_centers):
  <span class=hljs-keyword >for</span> loc <span class=hljs-keyword >in</span> centers:
    hats_with_point[loc] += [hat_index]</code></pre> <p>We are ready to create a tiling with Z3. I tell Z3 to keep track of a boolean value for each possible location for a hat tile.</p> <pre><code class="python hljs">hat_present = [z3.Bool(<span class=hljs-string >f&quot;hat<span class=hljs-subst >{i}</span>&quot;</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(hats))]
s = z3.Solver()</code></pre> <p>Then I input our tiling rules into the solver. In the first loop, I require that every kite must be a member of at most one hat. In the second loop, I require that kites in the interior of the region that I am tiling must be a member of at least one hat.</p> <pre><code class="python hljs">max_pop = <span class=hljs-built_in >max</span>(<span class=hljs-built_in >len</span>(c) <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items())
full_points = np.array([p <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items() <span class=hljs-keyword >if</span> <span class=hljs-built_in >len</span>(c) == max_pop])
all_points = np.array([p <span class=hljs-keyword >for</span> p, c <span class=hljs-keyword >in</span> hats_with_point.items()])
<span class=hljs-keyword >def</span> <span class="hljs-title function_">atleastone</span>(<span class=hljs-params >solver, bools</span>):
  solver.add(z3.Or(bools))
<span class=hljs-keyword >def</span> <span class="hljs-title function_">atmostone</span>(<span class=hljs-params >solver, bools</span>):
  <span class=hljs-comment >#solver.add(z3.PbLe([(x,1) for x in bools], 1))</span>
  <span class=hljs-keyword >for</span> i, b1 <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(bools):
    <span class=hljs-keyword >for</span> j, b2 <span class=hljs-keyword >in</span> <span class=hljs-built_in >enumerate</span>(bools):
      <span class=hljs-keyword >if</span> i &gt; j:
        solver.add(z3.Not(z3.And(b1, b2)))
<span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> all_points:
  atmostone(s, [hat_present[i] <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> hats_with_point[p]])
<span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> full_points:
  atleastone(s, [hat_present[i] <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> hats_with_point[p]])
<span class=hljs-built_in >print</span>(s.check())</code></pre> <p>Here, I wanted to use the built in function for counting the number of Bools that are true, PbLe, but it caused performance to tank. Manually specifying that each pair of hats covering a point cannot both be true somehow solves much faster. <code>s.check</code> computes a value for each boolean that together satisfy all constraints. All that&#39;s left is to plot the tiling.</p> <p>This is the place to be creative, but instead I just drew the outline of each hat in black.</p> <pre><code class="python hljs">m = s.model()
chosen_hats = np.array([z3.is_true(m[h]) <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> hat_present])
hat = np.<span class=hljs-built_in >round</span>(hat, <span class=hljs-number >2</span>)
segments = np.concatenate([hat[:, <span class=hljs-number >1</span>:, <span class=hljs-literal >None</span>], hat[:, :-<span class=hljs-number >1</span>, <span class=hljs-literal >None</span>]], axis=<span class=hljs-number >2</span>)
segments = segments.reshape(-<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)
reversed_segments = <span class=hljs-built_in >set</span>(((seg[<span class=hljs-number >1</span>], seg[<span class=hljs-number >0</span>]) <span class=hljs-keyword >for</span> seg <span class=hljs-keyword >in</span> segments))
outline = np.array([l <span class=hljs-keyword >for</span> l <span class=hljs-keyword >in</span> segments <span class=hljs-keyword >if</span> <span class=hljs-built_in >tuple</span>(l) <span class=hljs-keyword >not</span> <span class=hljs-keyword >in</span> reversed_segments])
outlines = outline[<span class=hljs-literal >None</span>, :] * six_rotations[:, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
outlines = np.concatenate([outlines, np.real(outlines) - <span class=hljs-number >1j</span> * np.imag(outlines)])
outlines = outlines[<span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, :, :, :] + hexagon_centers[:, :, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>, <span class=hljs-literal >None</span>]
outlines = np.reshape(outlines, (-<span class=hljs-number >1</span>, <span class=hljs-built_in >len</span>(outline), <span class=hljs-number >2</span>))
result = outlines[np.array(chosen_hats), :]
result = result.reshape(-<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)
plt.plot(result.imag.transpose(), result.real.transpose(), c=[<span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>])
plt.ylim(<span class=hljs-number >6</span>, <span class=hljs-number >17</span>)
plt.xlim(-<span class=hljs-number >1</span>, <span class=hljs-number >15</span>)
plt.gca().set_aspect(<span class=hljs-string >&quot;equal&quot;</span>)
plt.show()</code></pre> <img src="/assets/HatTile/code/Unknown-10.png" alt=""> <p>To run the code in the cloud and try variations, head to this <a href="https://colab.research.google.com/drive/1cBs3HGFQ6cz8z9o5HIr2OqhpD5A3LcqO?usp&#61;sharing">colab notebook&#33;</a></p> <p>External Links:</p> <p><a href="https://www.nhatcher.com/post/on-hats-and-sats/">https://www.nhatcher.com/post/on-hats-and-sats/</a></p> <div class=page-foot > <div> <a href=https://subdavis.com>subdavis.com </a> <a href=http://forrestli.con>forrestli.com</a> <div class=copyright > &copy; Hastings Greer. Last modified: April 10, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div>