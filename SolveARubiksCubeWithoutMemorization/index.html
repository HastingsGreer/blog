<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=stylesheet  href="https://apj.hgreer.com/blog"> <link rel=icon  href="/assets/favicon.png"> <script> fetch("https://apj.hgreer.com/referrer?" + document.referrer); </script> <title>Solve a Rubiks Cube with pen and paper and no memorized algorithms</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <!-- <li><a href="/FeatureMapICON/">Feature Map Inverse Consistency</a> --> <li><a href="/HatTile/">Aperiodic Tiling with Z3</a> <!-- <li><a href="/ICON/">Inverse Consistent Regstration</a> <li><a href="/Mandelbrot/">Mandelbrot Set Adventures</a> --> <li><a href="/JavascriptMandelbrot/">Mandelbrot Set</a> <li><a href="/TrebuchetSimulator/">Trebuchet Simulator</a> <li><a href="/BadMatrixMultiply/">Bad Matrix Multiplication</a> <li><a href="/TwistyPuzzle/">Twisty Puzzles</a> <li><a href="/GameJam/">Game Jam Games</a> <li><a href="/AIMusings/">Alignment Musings</a> <li><a href="/menu3/">Tags</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=solve_a_rubiks_cube_with_pen_and_paper_and_no_memorized_algorithms ><a href="#solve_a_rubiks_cube_with_pen_and_paper_and_no_memorized_algorithms" class=header-anchor >Solve a Rubiks Cube with pen and paper and no memorized algorithms</a></h1> <p>You&#39;ve probably seen tutorials on how to solve a rubiks cube- but did they seem deeply unsatisfying? They introduce long sequences of moves that must be memorized, without explaining how they were created. If you want to solve a Rubiks cube again years later, if you have forgotten a single step of one of these sequences, you are up a creek without a paddle unless you have internet access to learn again.</p> <p>No longer&#33; Once you have followed this tutorial, you will permanently be able to solve a rubiks cube. Your future solves may take a few hours and and require pencil and paper, but they will not require internet access. This is a tutorial about inventing sequences, not memorizing them. Thus, whenever we show specific move sequences, they will solve a different, freely available online puzzle- if you want cubey victory, you will then have to work out analogous cubey sequences. </p> <p>But first, an aside. If you have read other guides on rubiks cubes, you may have three sticky ideas in your head: one good and two bad. The good idea is that we don&#39;t need to solve stickers- we need to solve pieces. Each sticker is attached to a piece, and a sticker that is on the right colored side does you no good if other stickers on the same piece are on the wrong colored sides. Now, the bad ideas: someone may have taught you that &quot;the centers never move.&quot; Nonsense- hold the top and bottom layers fixed, and turn the middle layer&#33; Look- the centers moved. This sort of turn is important to <em>easily</em> solving the cube. It&#39;s a different way of looking at the same problem, but the difference is important. Second, you probably were taught to solve the cube layer by layer. This is one of the <em>fastest</em> ways to solve a cube, but it is not the easiest to invent: it is much easier to solve corners, then edges, and then centers. These are linked: once you see that moving the middle slice is valid, it becomes clear that moving any middle slice doesn&#39;t affect the corners. Thus, once you have solved the corners, you can freely experiment with 3 distinct middle slice moves without disturbing the corners. This is much more freedom than the layer by layer approach, where after solving a layer, you only have a single safe move remaining.</p> <p>This is the last time we will mention a cube- remember, solve corners then centers then edges. </p> <p>Simon Tatham&#39;s &quot;Twiddle&quot;</p> <p>https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/twiddle.html#4x4n3</p> <p>animation of random piece moves</p> <p>Two classes of piece- no move ever wil put 1 in the slot where 2 belongs. We will solve 1 class, then the other.</p> <p>First piece class</p> <h1 id=technique_a_go_as_far_as_you_can_intuitively_leaving_yourself_freedom ><a href="#technique_a_go_as_far_as_you_can_intuitively_leaving_yourself_freedom" class=header-anchor >Technique A. Go as far as you can intuitively, leaving yourself freedom</a></h1> <p>Solving the piece 1 is easy- just move it to the top left corner. </p> <p>Solving the piece 3 is easy- just move it to the top center right</p> <p>Solving 6 would be easy, but now we have no free moves left. Instead, lets solve 9. This leaves 5 pieces unsolved, and we can rotate them all freely. However, with only one free rotation left, we can no longer make changes to the puzzle without disturbing our solved pieces</p> <p>technique B: take it out, then put it back</p> <p>We first write down the locations of our unsolved pieces.</p> <p>6 11 16 14 8</p> <p>We then take out the 3, and then put it back using a different sequence of moves. &#40;Depending on available working memory, it&#39;s probably best to write this sequence down&#41;. we denote the 4 possible moves</p> <p>ab cd</p> <p>and perform </p> <p>bdddb</p> <p>The unsolved pieces are now </p> <p>11 6 14 8 16</p> <p>lets rotate this to resemble the original locations, making our sequence</p> <p>bdddbd</p> <p>6 16 14 11 8</p> <p>and what we have found is a sequence that &#40;restricted to the first class of pieces&#41; cycles a diagonal of three pieces: 3 cycles are deeply useful sequences. By alternating rotating the bottom square and peforming this sequence to permute along the diagonal, it is easy to solve the remaining pieces of the first class. This introduces <em>parity</em>: you may find yourself in a situation where it appears that you need to swap 2 pieces, which is impossible to achieve with any sequence of 3 piece cycles. However, this is an illusion, as <em>rotating the bottom square once</em> performs a 4 piece permutation, which can be combined with a 3 piece cycle to create a 2 piece cycle &#40;hint hint&#41;</p> <p>animation of solving first class.</p> <p>Now, on to the second class of piece.</p> <h1 id=technique_c_moves_that_commute_with_respect_to_a_class ><a href="#technique_c_moves_that_commute_with_respect_to_a_class" class=header-anchor >Technique C: moves that commute with respect to a class</a></h1> <p>Check it out- any sequence of top left and bottom right moves where the total number of top left and bottom right moves both add to 4, don&#39;t affect any of the first class of piece.</p> <p>This is because the top left move only affects 1 3 9 11, and the bottom right only affects 6 8 14 16. Therefore, as far as the first class pieces are concerned, these moves commute: you can swap two moves in the sequence without affecting the outcome. This gives us a rich collection of sequences to experiment with, analogous to the collection of possible &quot;Take it out and put it back&quot; sequences from Technique B. Because these sequences are guaranteed to not move the first class pieces, they are also cheap to experiment with after solving the first class- we won&#39;t lose our work. //&#40;I cannot resist another hint: once you have solved corners on the rubiks cube, any middle slice move commutes with a side move with respect to the corners&#41;</p> <p>As a standard step in investigating a sequence, we will write down the locations of all the second class pieces before and after performing it. </p> <p>First, we try AADDAADD</p> <p>cycles like 2 triangles- not that useful</p> <p>ADDDAADD</p> <p>a 5 cycle, not that useful</p> <p>adadadad</p> <p>5 cycle</p> <p>adddaaad</p> <p>Ah- two 2-cycles. This is usable to solve most of the class 2 pieces</p> <h1 id=technique_d_size_of_orbits_permutations_and_repeated_sequences ><a href="#technique_d_size_of_orbits_permutations_and_repeated_sequences" class=header-anchor >Technique D: size of orbits, permutations, and repeated sequences</a></h1> <p>Basically, any short sequence of moves will, after being repeated enough times, restore the puzzle to its initial state. However, the way that it does so can be very useful. Specifically, any sequence of moves will execute a number of cycles in the locations of the pieces of the puzzle. If you execute the sequence a number of times that is divisible by the length of a cycle, those pieces won&#39;t move. If the cycles are different lengths, then you can isolate one cycle by performing the sequence the length of another cycle.</p> <p>The cycles in location space are often different lengths than the cycles in orientation space</p> <p>AC x 4 rotates 8 pieces in place</p> <p>Heyyyyy, since AC is the identity function with respect to piece location, then it commutes with any other sequence with respect to piece location</p> <p>C- C- C- Combo move</p> <p>AC x 4 BB AC x 12 BB rotates just two pieces&#33;</p> <p>Twiddle: ACC x 6 ACCC x 4 rotates two pieces same direction</p> <p>AC x 4 BB AC x 12 BB rotates two different directions</p> <h1 id=technique_e_fuck_all_that_claude_-_smt_solver ><a href="#technique_e_fuck_all_that_claude_-_smt_solver" class=header-anchor >Technique E: fuck all that, Claude -&gt; SMT solver</a></h1> <p>Wait&#33; We aren&#39;t cavemen. We have technology.</p> <p>Spongebob smashing dollar meme</p> <div class=page-foot > <div> <a href=https://subdavis.com>subdavis.com </a> <a href=http://forrestli.con>forrestli.com</a> <div class=copyright > &copy; Hastings Greer. Last modified: November 04, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div>