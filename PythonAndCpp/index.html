<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=stylesheet  href="https://apj.hgreer.com/blog"> <link rel=icon  href="/assets/favicon.png"> <title>Why every project ends up having a metalanguage and an inner language</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <!-- <li><a href="/FeatureMapICON/">Feature Map Inverse Consistency</a> --> <li><a href="/HatTile/">Aperiodic Tiling with Z3</a> <!-- <li><a href="/ICON/">Inverse Consistent Regstration</a> <li><a href="/Mandelbrot/">Mandelbrot Set Adventures</a> --> <li><a href="/JavascriptMandelbrot/">Mandelbrot Set</a> <li><a href="/TrebuchetSimulator/">Trebuchet Simulator</a> <li><a href="/BadMatrixMultiply/">Bad Matrix Multiplication</a> <li><a href="/GameJam/">Game Jam Games</a> <li><a href="/menu3/">Tags</a> </ul> </div> <div id=main > <div class=franklin-content ><p>There&#39;s a sudden swarm of compute intensive projects being written in Python instead of C and its descendants. Specifically, while in performance sensitive, latency sensitive projects C&#40;&#43;&#43;&#41; is still king, incredibly compute intensive and throughput sensitive projects are suddenly being written in a language where for loops are 100x slower. The core example is of course neural network training. What&#39;s going on? Basically, python is both easier to learn for novices, less bug prone for experts, and has a faster interpreter than C&#43;&#43;. </p> <p>C&#43;&#43; interpreter? Well of course, C is faster than python. But C&#43;&#43;, <a href="https://en.wikipedia.org/wiki/Cfront">from the beginning</a>, is a turing complete interpreted language that outputs C code. Python has a faster interpreter than C&#43;&#43; template metaprograms, which are the C-descendant programs python is actually competing with.</p> <h1 id=why_every_project_ends_up_having_a_metalanguage_and_an_inner_language ><a href="#why_every_project_ends_up_having_a_metalanguage_and_an_inner_language" class=header-anchor >Why every project ends up having a metalanguage and an inner language</a></h1> <p>What is the fastest way to add 4 numbers in a function? In our dreams, it&#39;s</p> <pre><code class="c hljs"><span class=hljs-type >int</span> sum = <span class=hljs-number >0</span>;
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i = <span class=hljs-number >0</span>; i &lt; number_elements; i++) {
  sum += *(++<span class=hljs-built_in >array</span>);
}</code></pre> <p>If number_elements is known at compile time, we really want the compiled program to be</p> <pre><code class="julia hljs">sum = *(array)
sum += *(array + <span class=hljs-number >1</span>)
sum += *(array + <span class=hljs-number >2</span>)
sum += *(array + <span class=hljs-number >3</span>)</code></pre> <p>How do we get that? C&#43;&#43; has a wonderful answer. As long as number_elements is </p> <h1 id=structure_of_a_high_performance_codebase ><a href="#structure_of_a_high_performance_codebase" class=header-anchor >Structure of a High Performance codebase</a></h1> <p>Typical C Structure:</p> <p>Metalanguage produces program written in inner language. inner program is compiled inner program processes input metadata inner program processes input and produces output</p> <p>Python Structure:</p> <p>Metalanguage processes input metadata Metalanguage produces program written in inner language inner program is compiled inner program processes input and produces output</p> <h1 id=language_diversity_vs_metalanguage_diversity ><a href="#language_diversity_vs_metalanguage_diversity" class=header-anchor >Language diversity vs metalanguage diversity </a></h1> <p>High performance C/C&#43;&#43; is many interpreted metalanguages targetting a single high performance compiled language. C&#43;&#43;, CMake, m4, autoconf, Template Programs are all metalanguages that produce C.</p> <p>High performance python is a single interpreted metalanguage, Python, targetting many high performance compiled languages like torch, jax, tensorflow, sql, z3. It turns out that </p> <h1 id=turing_completeness ><a href="#turing_completeness" class=header-anchor >Turing completeness</a></h1> <p>For maintainability, you don&#39;t really want your object language and your metalanguage to both be turing complete. Traditionally when writing C or C descendants, this has been managed by picking a weak metalanguage like macro substitution, or even just by reprimanding Jimmy from MIT when he submits a pull request that&#39;s calculating primes at compile time using SFINAE. </p> <div class=page-foot > <div> <a href=https://subdavis.com>subdavis.com </a> <a href=http://forrestli.con>forrestli.com</a> <div class=copyright > &copy; Hastings Greer. Last modified: May 08, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div>